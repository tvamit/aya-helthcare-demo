<!DOCTYPE html>
<html lang="hi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hospital AI Voice Assistant | ‡§Ö‡§∏‡•ç‡§™‡§§‡§æ‡§≤ ‡§è‡§Ü‡§à ‡§∏‡§π‡§æ‡§Ø‡§ï</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 30px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 600px;
        width: 100%;
        padding: 40px;
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        color: #667eea;
        font-size: 28px;
        margin-bottom: 10px;
      }

      .header p {
        color: #666;
        font-size: 14px;
      }

      .voice-button {
        width: 200px;
        height: 200px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-size: 80px;
        cursor: pointer;
        margin: 30px auto;
        display: block;
        transition: all 0.3s ease;
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      }

      .voice-button:hover {
        transform: scale(1.05);
        box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
      }

      .voice-button:active {
        transform: scale(0.95);
      }

      .voice-button.recording {
        animation: pulse 1.5s infinite;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      .voice-button.speaking {
        animation: speaking 0.8s infinite;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        pointer-events: none;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      @keyframes speaking {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 10px 30px rgba(56, 239, 125, 0.4);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 15px 50px rgba(56, 239, 125, 0.8);
        }
      }

      .status {
        text-align: center;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 15px;
        margin: 20px 0;
        min-height: 80px;
      }

      .status h3 {
        color: #333;
        font-size: 16px;
        margin-bottom: 10px;
      }

      .status p {
        color: #666;
        font-size: 14px;
        line-height: 1.6;
      }

      .conversation {
        max-height: 300px;
        overflow-y: auto;
        margin: 20px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 15px;
      }

      .message {
        margin: 10px 0;
        padding: 12px 18px;
        border-radius: 15px;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .message.user {
        background: #667eea;
        color: white;
        margin-left: 20%;
        text-align: right;
      }

      .message.ai {
        background: #e9ecef;
        color: #333;
        margin-right: 20%;
        padding-right: 50px;
        position: relative;
      }

      .replay-btn {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        background: #667eea;
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
      }

      .replay-btn:hover {
        background: #5568d3;
        transform: translateY(-50%) scale(1.1);
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .btn {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 10px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 600;
      }

      .btn-primary {
        background: #667eea;
        color: white;
      }

      .btn-primary:hover {
        background: #5568d3;
      }

      .btn-secondary {
        background: #e9ecef;
        color: #333;
      }

      .btn-secondary:hover {
        background: #dee2e6;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        margin-top: 30px;
      }

      .stat-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 15px;
        text-align: center;
      }

      .stat-card h4 {
        font-size: 24px;
        margin-bottom: 5px;
      }

      .stat-card p {
        font-size: 12px;
        opacity: 0.9;
      }

      .loader {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none;
      }

      .error {
        background: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 10px;
        margin: 10px 0;
      }

      @media (max-width: 600px) {
        .container {
          padding: 20px;
        }

        .voice-button {
          width: 150px;
          height: 150px;
          font-size: 60px;
        }

        .stats {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üè• Hospital AI Assistant</h1>
        <p>Speak in Hindi or English</p>
      </div>

      <button class="voice-button" id="voiceBtn">üé§</button>

      <div class="status" id="status">
        <h3>Ready to Help</h3>
        <p>Press the mic button and ask your question</p>
      </div>

      <div class="conversation" id="conversation"></div>

      <div class="controls">
        <button class="btn btn-secondary" id="clearBtn">Clear Chat</button>
        <button class="btn btn-primary" id="statsBtn">View Stats</button>
      </div>

      <div class="stats hidden" id="stats">
        <div class="stat-card">
          <h4 id="bedsAvailable">-</h4>
          <p>Beds Available</p>
        </div>
        <div class="stat-card">
          <h4 id="doctorsAvailable">-</h4>
          <p>Doctors Available</p>
        </div>
        <div class="stat-card">
          <h4>24/7</h4>
          <p>Emergency</p>
        </div>
      </div>
    </div>

    <script>
      const API_URL = "http://localhost:3000/api";

      // Generate unique sessionId for this user session
      // Use localStorage to persist sessionId across page refreshes, or generate new one
      let sessionId = localStorage.getItem("sessionId");
      if (!sessionId) {
        sessionId =
          "session-" +
          Date.now() +
          "-" +
          Math.random().toString(36).substr(2, 9);
        localStorage.setItem("sessionId", sessionId);
      }

      let mediaRecorder;
      let audioChunks = [];
      let isRecording = false;
      let currentAudio = null;
      let currentAudioUrl = null;

      const voiceBtn = document.getElementById("voiceBtn");
      const status = document.getElementById("status");
      const conversation = document.getElementById("conversation");
      const clearBtn = document.getElementById("clearBtn");
      const statsBtn = document.getElementById("statsBtn");
      const statsSection = document.getElementById("stats");

      // Voice button click handler
      voiceBtn.addEventListener("click", async () => {
        // If AI is speaking, stop it
        if (voiceBtn.classList.contains("speaking")) {
          stopAudioPlayback();
          return;
        }

        // Otherwise, handle recording
        if (!isRecording) {
          await startRecording();
        } else {
          await stopRecording();
        }
      });

      // Stop audio playback
      function stopAudioPlayback() {
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
        }

        // Reset UI to ready state
        voiceBtn.classList.remove("speaking");
        voiceBtn.textContent = "üé§";
        updateStatus("Stopped", "Audio stopped. Ready for next question.");

        // Auto-reset to "Ready to Help" after 2 seconds
        setTimeout(() => {
          updateStatus("Ready to Help", "Ask your next question");
        }, 2000);
      }

      // Start recording
      async function startRecording() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };

          mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
            await sendAudioToAPI(audioBlob);
            stream.getTracks().forEach((track) => track.stop());
          };

          mediaRecorder.start();
          isRecording = true;

          voiceBtn.classList.add("recording");
          voiceBtn.textContent = "‚èπÔ∏è";
          updateStatus("Recording...", "Speak now... Listening");
        } catch (error) {
          console.error("Error accessing microphone:", error);
          showError(
            "Microphone access denied. Please allow microphone permission."
          );
        }
      }

      // Stop recording
      async function stopRecording() {
        if (mediaRecorder && isRecording) {
          mediaRecorder.stop();
          isRecording = false;

          voiceBtn.classList.remove("recording");
          voiceBtn.textContent = "‚è≥";
          updateStatus("Thinking...", "AI is thinking...");
        }
      }

      // Send audio to API
      async function sendAudioToAPI(audioBlob) {
        try {
          const formData = new FormData();
          formData.append("audio", audioBlob, "recording.wav");

          const response = await fetch(
            `${API_URL}/ai/voice-query?sessionId=${encodeURIComponent(
              sessionId
            )}`,
            {
              method: "POST",
              body: formData,
            }
          );

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          // Get transcription and response from headers
          const transcription = decodeURIComponent(
            response.headers.get("X-Transcription") || "Audio processed"
          );
          const responseText = decodeURIComponent(
            response.headers.get("X-Response-Text") || "Processing..."
          );

          // Log user input to console
          console.log("üë§ User Input:", transcription);

          // Log AYA response to console
          console.log("ü§ñ AYA Response:", responseText);

          // Add to conversation
          addMessage(transcription, "user");
          addMessage(responseText, "ai", true); // true = add replay button

          // Play audio response
          const responseAudioBlob = await response.blob();
          currentAudioUrl = URL.createObjectURL(responseAudioBlob);
          currentAudio = new Audio(currentAudioUrl);

          // IMMEDIATELY update UI to speaking state
          voiceBtn.classList.add("speaking");
          voiceBtn.textContent = "‚èπÔ∏è"; // Stop icon
          voiceBtn.title = "Click to stop";
          updateStatus("Aya Speaking...", "Click mic to stop");

          // Play audio
          currentAudio.play().catch((err) => {
            console.error("Audio play failed:", err);
          });

          // When audio ends OR on error, ALWAYS reset to ready state
          const resetUI = () => {
            voiceBtn.classList.remove("speaking");
            voiceBtn.textContent = "üé§";
            voiceBtn.title = "Click to speak";
            updateStatus("Ready to Help", "Ask your next question");
          };

          currentAudio.onended = resetUI;
          currentAudio.onerror = resetUI;
        } catch (error) {
          console.error("Error:", error);
          showError(
            "Failed to process audio. Please check if backend services are running."
          );
          // ALWAYS reset UI on error
          voiceBtn.classList.remove("speaking", "recording");
          voiceBtn.textContent = "üé§";
          updateStatus("Ready to Help", "Click mic to try again");
        }
      }

      // Add message to conversation
      function addMessage(text, type, allowReplay = false) {
        // Log message addition to console for debugging
        console.log(
          `üí¨ Adding ${type === "user" ? "User" : "AI"} Message:`,
          text
        );

        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${type}`;
        messageDiv.textContent = text;

        // Add replay button for AI messages
        if (type === "ai" && allowReplay) {
          const replayBtn = document.createElement("button");
          replayBtn.className = "replay-btn";
          replayBtn.innerHTML = "üîä";
          replayBtn.title = "Replay response";
          replayBtn.onclick = () => {
            if (currentAudio) {
              // Stop if currently playing
              currentAudio.pause();
              currentAudio.currentTime = 0;

              // Update UI to speaking state
              voiceBtn.classList.add("speaking");
              voiceBtn.textContent = "‚èπÔ∏è";
              voiceBtn.title = "Click to stop";
              updateStatus("Aya Speaking...", "Click mic to stop");

              // Play audio
              currentAudio.play();

              // Reset when done
              currentAudio.onended = () => {
                voiceBtn.classList.remove("speaking");
                voiceBtn.textContent = "üé§";
                voiceBtn.title = "Click to speak";
                updateStatus("Ready to Help", "Ask your next question");
              };
            }
          };
          messageDiv.appendChild(replayBtn);
        }

        conversation.appendChild(messageDiv);
        conversation.scrollTop = conversation.scrollHeight;
      }

      // Update status
      function updateStatus(title, message) {
        status.innerHTML = `<h3>${title}</h3><p>${message}</p>`;
      }

      // Show error
      function showError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "error";
        errorDiv.textContent = message;
        conversation.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 5000);
      }

      // Clear conversation
      clearBtn.addEventListener("click", async () => {
        try {
          // Call reset endpoint to clear backend session
          await fetch(`${API_URL}/ai/reset-session`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ sessionId }),
          });
        } catch (error) {
          console.error("Error resetting session:", error);
          // Continue with UI reset even if backend call fails
        }

        // Clear UI conversation
        conversation.innerHTML = "";
        updateStatus(
          "Ready to Help",
          "Press the mic button and ask your question"
        );
      });

      // Toggle stats
      statsBtn.addEventListener("click", async () => {
        statsSection.classList.toggle("hidden");
        if (!statsSection.classList.contains("hidden")) {
          await loadStats();
        }
      });

      // Load statistics
      async function loadStats() {
        try {
          const [bedsRes, doctorsRes] = await Promise.all([
            fetch(`${API_URL}/beds?available=true`),
            fetch(`${API_URL}/doctors?available=true`),
          ]);

          const beds = await bedsRes.json();
          const doctors = await doctorsRes.json();

          document.getElementById("bedsAvailable").textContent =
            beds.count || 0;
          document.getElementById("doctorsAvailable").textContent =
            doctors.count || 0;
        } catch (error) {
          console.error("Error loading stats:", error);
        }
      }

      // Initial load
      updateStatus(
        "Ready to Help",
        "Press the mic button and ask your question"
      );
    </script>
  </body>
</html>
